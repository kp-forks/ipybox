{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ipybox","text":"<p>Next generation ipybox</p> <p>This is the next generation of ipybox, a complete rewrite. Older versions are maintained on the 0.6.x branch and can be obtained with <code>pip install ipybox&lt;0.7</code>.</p> <p>ipybox is a Python code execution sandbox with first-class support for programmatic MCP tool calling. It generates a typed Python tool API from MCP server tool schemas, supporting both local stdio and remote HTTP servers. Code that calls the generated API executes in a sandboxed IPython kernel, providing a stateful environment where variables and definitions persist across executions. The generated API delegates MCP tool execution to a separate environment that enforces tool call approval, requiring applications to explicitly accept or reject each tool call before it executes.</p> <p> </p> <code>CodeExecutor</code> coordinates sandboxed code execution, tool execution, and tool call approval."},{"location":"#agent-integration","title":"Agent integration","text":"<p>ipybox is designed for agents that interact with their environment through code actions rather than JSON tool calls, a more reliable approach since LLMs are heavily pretrained on Python code compared to JSON tool call post-training. Agents generate and execute Python code that composes multiple MCP tool calls into a single action, using loops, conditionals, and data transformations that keep intermediate results out of the agent's context window. Since agent-generated code cannot be trusted, it must run in a secure sandboxed environment, and all MCP tool calls must be approved by the application. ipybox supports both with minimal setup.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Stateful code execution \u2014 state persists across executions in IPython kernels</li> <li>Lightweight sandboxing \u2014 kernel isolation via Anthropic's sandbox-runtime</li> <li>Generated Python tool API \u2014 functions and models generated from MCP tool schemas</li> <li>Programmatic MCP tool calling \u2014 MCP tools called via Python code, not JSON directly</li> <li>MCP tool call approval \u2014 every MCP tool call requires application-level approval</li> <li>Any MCP server \u2014 supports stdio, Streamable HTTP, and SSE transports</li> <li>Any Python package \u2014 install and use any Python package in IPython kernels</li> <li>Local code execution \u2014 no cloud dependencies, everything runs on your machine</li> <li>Python SDK and MCP server \u2014 use ipybox programmatically or as an MCP server</li> <li>Claude Code plugin \u2014 a plugin for programmatic tool calling in Claude Code</li> </ul>"},{"location":"#llm-friendly-documentation","title":"LLM-friendly documentation","text":"<p>For LLM-friendly versions of this documentation, see llms.txt and llms-full.txt.</p>"},{"location":"apigen/","title":"Python tool API generation","text":"<pre><code>from ipybox import generate_mcp_sources\n</code></pre> <p><code>generate_mcp_sources()</code> generates a typed Python tool API from MCP server tool schemas. Each tool becomes a module with a Pydantic <code>Params</code> class, a <code>Result</code> class or <code>str</code> return type, and a <code>run()</code> function.</p>"},{"location":"apigen/#stdio-servers","title":"Stdio servers","text":"<p>For MCP servers that run as local processes, specify <code>command</code>, <code>args</code>, and optional <code>env</code>:</p> <pre><code>brave_mcp_params = {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@brave/brave-search-mcp-server\", \"--transport\", \"stdio\"],\n    \"env\": {\"BRAVE_API_KEY\": \"${BRAVE_API_KEY}\"},\n}\n\nawait generate_mcp_sources(\n    server_name=\"brave_search\",\n    server_params=brave_mcp_params,\n    root_dir=Path(\"mcptools\"),\n)\n</code></pre>"},{"location":"apigen/#http-servers","title":"HTTP servers","text":"<p>For remote MCP servers over HTTP, specify <code>url</code> and optional <code>headers</code>:</p> <pre><code>github_mcp_params = {\n    \"url\": \"https://api.githubcopilot.com/mcp/\",\n    \"headers\": {\"Authorization\": \"Bearer ${GITHUB_API_KEY}\"},\n}\n\nawait generate_mcp_sources(\n    server_name=\"github\",\n    server_params=github_mcp_params,\n    root_dir=Path(\"mcptools\"),\n)\n</code></pre> <p>ipybox auto-detects the transport type from the URL. URLs containing <code>/mcp</code> use streamable HTTP, URLs containing <code>/sse</code> use SSE. You can also set <code>type</code> explicitly to <code>\"streamable_http\"</code> or <code>\"sse\"</code>.</p>"},{"location":"apigen/#environment-variable-substitution","title":"Environment variable substitution","text":"<p>You can use <code>${VAR_NAME}</code> placeholders in <code>server_params</code> values. ipybox replaces them with the corresponding environment variable when connecting to the MCP server. This keeps secrets out of your code.</p>"},{"location":"apigen/#generated-package-structure","title":"Generated package structure","text":"<p>The Brave Search MCP server example above generates a package structure like this:</p> <pre><code>mcptools/\n\u2514\u2500\u2500 brave_search/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 brave_web_search.py\n    \u251c\u2500\u2500 brave_local_search.py\n    \u251c\u2500\u2500 brave_image_search.py\n    \u2514\u2500\u2500 ...\n</code></pre> <p>For each MCP server tool, a separate Python module is generated, named after the tool.</p>"},{"location":"apigen/#using-the-generated-api","title":"Using the generated API","text":"<p>Each module provides a typed interface for programmatic MCP tool calls:</p> <pre><code>from mcptools.brave_search.brave_image_search import Params, Result, run\n\n# Params validates input\nparams = Params(query=\"neural topic models\", count=3)\n\n# run() calls the MCP tool and returns a Result (or str for untyped tools)\nresult: Result = run(params)\n\nfor image in result.items:\n    print(image.title)\n</code></pre> <p>The <code>Params</code> class is generated from the tool's input schema. Tools with an output schema get a typed <code>Result</code> class; others return <code>str</code>. The MCP tool itself is called via its <code>run()</code> function.</p>"},{"location":"ccplugin/","title":"Programmatic tool calling plugin for Claude Code","text":"<p>This plugin installs the ipybox MCP server in Claude Code along with a <code>codeact</code><sup>1</sup> skill. It enables Claude Code to act by generating and executing code rather than JSON tool calls. The generated code calls MCP tools and previously saved code actions programmatically. </p> <p>With this \"code as tool\" approach, saved code actions become tools themselves, available for use in future code actions. Over time, a library of code actions can be built, each composing other code actions and MCP tools.</p> <p>The <code>codeact</code> skill provides guidance for Claude Code to discover MCP tools and code actions via agentic filesystem search, inspect the interfaces of relevant tools, generate code actions that use them, and save successful code actions for later reuse. </p> <p>Tool search and inspection is performed on demand based on the current task. This progressive disclosure approach frees Claude Code from pre-loading tool sources into its context window, saving tokens and improving performance.</p> <p>Code actions are stored with interface separated from implementation. This separation lets Claude Code inspect only the interface without being distracted by implementation details, further reducing token consumption during tool discovery.</p> <p>Note</p> <p>This plugin is a demonstration of the \"code as tool\" approach. It is a prototype that requires further optimization and refinement.</p> <p>The <code>codeact</code> skill distributes responsibilities between ipybox and Claude Code:</p> <p>ipybox:</p> <ul> <li>Generates typed Python tool APIs from MCP server tool schemas</li> <li>Executes Python code that uses the generated MCP tool APIs</li> <li>Uses a stateful and sandboxed IPython kernel for code execution</li> </ul> <p>Claude Code:</p> <ul> <li>Discovers and selects MCP tools and stored code actions via agentic search</li> <li>Generates and executes code in ipybox that calls selected MCP tools and code actions</li> <li>Adds output parsers and structured result types to MCP tools that lack output schemas</li> <li>Saves successful code actions with a structure optimized for discovery and reuse</li> </ul>"},{"location":"ccplugin/#environment-setup","title":"Environment setup","text":"<p>The example below uses the GitHub MCP server. Create a <code>.env</code> file with your GitHub personal access token (PAT) in the current working directory:</p> .env<pre><code>GITHUB_API_KEY=your-github-personal-access-token\n</code></pre> <p>The plugin automatically loads environment variables from this file.</p>"},{"location":"ccplugin/#plugin-installation","title":"Plugin installation","text":"<p>Add the ipybox repository as plugin marketplace to Claude Code:</p> <pre><code>claude plugin marketplace add https://github.com/gradion-ai/ipybox\n</code></pre> <p>Then install one of the available plugins:</p> Plugin Description <code>codeact-default</code> Runs ipybox without a sandbox <code>codeact-sandbox</code> Runs ipybox with a sandboxed IPython kernel <code>codeact-docker</code> Runs ipybox as a Docker container <pre><code>claude plugin install codeact-default@ipybox\n</code></pre> <p>Warning</p> <p>Only one plugin from this marketplace should be active at a time. Having multiple plugins active simultaneously may cause conflicts.</p>"},{"location":"ccplugin/#sandbox-configuration","title":"Sandbox configuration","text":"<p>When using <code>codeact-sandbox</code>, you can optionally provide a <code>sandbox-config.json</code> file in the workspace directory to customize the sandbox configuration. If not provided, ipybox runs with the default sandbox.</p>"},{"location":"ccplugin/#usage-example","title":"Usage example","text":"<p>This example demonstrates a complete workflow: </p> <ul> <li>Registering an MCP server</li> <li>Using its tools programmatically</li> <li>Generating an output parser</li> <li>Chaining tools in a single code action</li> <li>Saving the code action for reuse</li> </ul> <p>It uses two tools from the GitHub MCP server: </p> <ul> <li><code>search_repositories</code></li> <li><code>list_commits</code></li> </ul>"},{"location":"ccplugin/#register-the-github-mcp-server","title":"Register the GitHub MCP server","text":"User prompt<pre><code>Register this MCP server at ipybox under name github:\n{\n  \"url\": \"https://api.githubcopilot.com/mcp/\",\n  \"headers\": {\n    \"Authorization\": \"Bearer ${GITHUB_API_KEY}\"\n  }\n}\n</code></pre> <p>The <code>${GITHUB_API_KEY}</code> placeholder is automatically replaced with the value from your <code>.env</code> file.</p> <p>This registers the GitHub MCP server and generates a typed Python API for its tools under <code>mcptools/github/</code>. Each tool becomes a module named after the tool (<code>search_repositories.py</code>, <code>list_commits.py</code>, etc.).</p>"},{"location":"ccplugin/#use-the-github-mcp-server-programmatically","title":"Use the GitHub MCP server programmatically","text":"<p>The codeact skill can be activated in Claude Code with phrases like \"use the codeact skill\" or similar:</p> User prompt<pre><code>Use the codeact skill to get the latest 5 commits of the 3 github repos \nof torvalds with the most stars. For each repo, output name, stars and \nthe first line of commit messages, and the link to the commit\n</code></pre> <p>Claude Code first lists directories under <code>mcptools/</code> to see which tools are available. It then reads the tool files search_repositories.py and list_commits.py to understand their interfaces, as these appear relevant to the task.</p> <p>Claude Code generates two code actions. The first searches for the top 3 repos of Linus Torvalds sorted by stars:</p> Code action<pre><code>import json\nfrom mcptools.github import search_repositories, list_commits\n\n# Search for torvalds' repositories sorted by stars (descending)\nrepos_result = search_repositories.run(search_repositories.Params(\n    query=\"user:torvalds\",\n    sort=search_repositories.Sort.stars,\n    order=search_repositories.Order.desc,\n    perPage=10,\n    minimal_output=False\n))\n\nrepos_data = json.loads(repos_result)\nprint(f\"Found {repos_data['total_count']} repos\")\n\n# Get top 3 repos\ntop_repos = repos_data['items'][:3]\nfor repo in top_repos:\n    print(f\"- {repo['name']}: {repo['stargazers_count']} stars\")\n</code></pre> <p>Here, Claude Code makes assumptions about the tool response structure. The GitHub MCP server tools do not provide output schemas, so Claude Code guesses the structure from its training data. These assumptions may or may not be correct depending on the MCP server's popularity, but in this example they work. MCP tools that provide output schemas get a generated <code>Result</code> class with typed fields, but the GitHub MCP server tools return unstructured strings. </p> <p>The second code action uses the repository information stored in <code>top_repos</code> to get the latest 5 commits of each repo:</p> Code action<pre><code># Get latest 5 commits for each of the top 3 repos\nfor repo in top_repos:\n    repo_name = repo['name']\n    stars = repo['stargazers_count']\n\n    print(f\"\\n{'='*60}\")\n    print(f\"\ud83d\udce6 {repo_name} | \u2b50 {stars:,} stars\")\n    print(f\"{'='*60}\")\n\n    # Get commits\n    commits_result = list_commits.run(list_commits.Params(\n        owner=\"torvalds\",\n        repo=repo_name,\n        perPage=5\n    ))\n\n    commits_data = json.loads(commits_result)\n\n    for i, commit in enumerate(commits_data[:5], 1):\n        sha = commit['sha']\n        short_sha = sha[:7]\n        message = commit['commit']['message'].split('\\n')[0]  # First line only\n        url = commit['html_url']\n\n        print(f\"\\n{i}. {message}\")\n        print(f\"   \ud83d\udd17 {url}\")\n</code></pre> <p>This prints the requested information. However, intermediate results were added to the agent's context window. To encourage Claude Code to chain <code>search_repositories</code> and <code>list_commits</code> in a single code action, we generate an output parser for <code>search_repositories</code>.</p>"},{"location":"ccplugin/#generate-an-output-parser","title":"Generate an output parser","text":"<p>To compensate for the lack of output schemas, we generate an output parser for the <code>search_repositories</code> tool:</p> User prompt<pre><code>Generate an output parser for search_repositories\n</code></pre> <p>This adds a <code>run_parsed()</code> function to search_repositories.py, returning a structured <code>ParseResult</code>. Claude Code infers this type by interacting with the tool using example inputs. The codeact skill encourages Claude Code to prioritize <code>run_parsed()</code> over <code>run()</code> when selecting tools.</p> <p>The parsing implementation details are stored in mcpparse/github/search_repositories.py. Keeping implementation separate from interface prevents polluting the interfaces that Claude Code inspects.</p>"},{"location":"ccplugin/#chaining-tools-in-a-single-code-action","title":"Chaining tools in a single code action","text":"<p>Running the same task again (optionally after restarting Claude Code), Claude Code now chains the tools in a single code action because it knows the structure of the <code>search_repositories</code> result up-front. It uses the new <code>run_parsed()</code> function and navigates the structured output based on the <code>ParseResult</code> type:</p> User prompt<pre><code>Use the codeact skill to get the latest 5 commits of the 3 github repos \nof torvalds with the most stars. For each repo, output name, stars and \nthe first line of commit messages, and the link to the commit\n</code></pre> Code action<pre><code>import json\nfrom mcptools.github import search_repositories, list_commits\n\n# Get Torvalds' repos sorted by stars\nrepos_result = search_repositories.run_parsed(\n    search_repositories.Params(\n        query=\"user:torvalds\",\n        sort=search_repositories.Sort.stars,\n        order=search_repositories.Order.desc,\n        perPage=3\n    )\n)\n\n# Get top 3 repos\ntop_repos = repos_result.repositories[:3]\nprint(f\"Found {len(top_repos)} repos\\n\")\n\nfor repo in top_repos:\n    print(f\"\ud83d\udce6 {repo.name} \u2b50 {repo.stargazers_count:,} stars\")\n    print(\"-\" * 60)\n\n    # Get latest 5 commits\n    commits_raw = list_commits.run(\n        list_commits.Params(\n            owner=\"torvalds\",\n            repo=repo.name,\n            perPage=5\n        )\n    )\n\n    # Parse the commits JSON\n    commits = json.loads(commits_raw)\n\n    for commit in commits[:5]:\n        sha = commit[\"sha\"][:7]\n        message = commit[\"commit\"][\"message\"].split(\"\\n\")[0]\n        url = commit[\"html_url\"]\n        print(f\"  {sha}: {message}\")\n        print(f\"         {url}\")\n\n    print()\n</code></pre>"},{"location":"ccplugin/#saving-code-actions-as-tools","title":"Saving code actions as tools","text":"<p>Code actions can be saved and reused as tools in later code actions. To save the previous code action, use a prompt like:</p> User prompt<pre><code>Save this as code action under github category with name commits_of_top_repos. \nMake username, top_n_repos and last_n_commits parameters\n</code></pre> <p>This creates a new package <code>gentools/github/commits_of_top_repos/</code> with an api.py module that defines the typed interface and an impl.py module that contains the implementation. </p> <p>The interface in <code>api.py</code> exposes the tool's parameters and return types and is relevant for understanding tool usage. The implementation in <code>impl.py</code> is not inspected by Claude Code during tool selection, saving token usage.</p>"},{"location":"ccplugin/#using-saved-code-actions-as-tools","title":"Using saved code actions as tools","text":"<p>After restarting Claude Code or clearing its context window, to enforce re-discovery of tools, the same task now uses the saved code action:</p> User prompt<pre><code>Use the codeact skill to get the latest 5 commits of the 3 github repos \nof torvalds with the most stars. For each repo, output name, stars and \nthe first line of commit messages, and the link to the commit\n</code></pre> Code action<pre><code>from gentools.github.commits_of_top_repos import run\n\nresults = run(username=\"torvalds\", top_n_repos=3, last_n_commits=5)\n\nfor repo in results:\n    print(f\"\\n## {repo.name} ({repo.stars:,} \u2b50)\")\n    print(\"-\" * 60)\n    for commit in repo.commits:\n        print(f\"\u2022 {commit.message}\")\n        print(f\"  {commit.url}\")\n</code></pre> <p>To conclude, the usage pattern in this example supports building a library of code actions. Each saved code action becomes a tool available for use in future code actions, enabling composition and reuse.</p> <ol> <li> <p>Executable Code Actions Elicit Better LLM Agents: https://arxiv.org/abs/2402.01030 \u21a9</p> </li> </ol>"},{"location":"codeexec/","title":"Code execution","text":"<pre><code>from ipybox import (\n    ApprovalRequest,\n    CodeExecutionChunk,\n    CodeExecutionResult,\n    CodeExecutor,\n)\n</code></pre> <p><code>CodeExecutor</code> runs Python code in an IPython kernel where variables and definitions persist across executions.</p>"},{"location":"codeexec/#basic-execution","title":"Basic execution","text":"<p>Use <code>execute()</code> for non-interactive execution where MCP tool calls, if any, are auto-approved:</p> <pre><code>async with CodeExecutor() as executor:\n    result = await executor.execute(\"print('hello world')\")\n    assert result.text == \"hello world\"\n</code></pre> <p>For application-level approval control, use <code>stream()</code> instead.</p>"},{"location":"codeexec/#tool-call-approval","title":"Tool call approval","text":"<p>When code calls the generated Python tool API, ipybox suspends execution and yields an <code>ApprovalRequest</code>. You must call <code>accept()</code> to continue execution:</p> <pre><code>code = \"\"\"\nfrom mcptools.brave_search.brave_image_search import Params, Result, run\n\nresult: Result = run(Params(query=\"neural topic models\", count=3))\nprint(f\"num results = {len(result.items)}\")\n\"\"\"\nasync with CodeExecutor() as executor:\n    async for item in executor.stream(code):\n        match item:\n            case ApprovalRequest():\n                assert item.tool_name == \"brave_image_search\"\n                assert item.tool_args[\"query\"] == \"neural topic models\"\n                assert item.tool_args[\"count\"] == 3\n                await item.accept()\n            case CodeExecutionResult():\n                assert item.text == \"num results = 3\"\n</code></pre> <p>The approval request includes <code>tool_name</code> and <code>tool_args</code> so you can inspect what's being called. Calling <code>reject()</code> raises a <code>CodeExecutionError</code>.</p>"},{"location":"codeexec/#stream-output-chunks","title":"Stream output chunks","text":"<p>Enable <code>chunks=True</code> to receive output incrementally as it's produced:</p> <pre><code>code = \"\"\"\nfrom time import sleep\nprint(\"chunk 1\")\nsleep(0.5)\nprint(\"chunk 2\")\n\"\"\"\nasync with CodeExecutor() as executor:\n    async for item in executor.stream(code, chunks=True):\n        match item:\n            case CodeExecutionChunk():\n                assert item.text.strip() in [\"chunk 1\", \"chunk 2\"]\n            case CodeExecutionResult():\n                assert item.text == \"chunk 1\\nchunk 2\"\n</code></pre> <p><code>CodeExecutionChunk</code> events contain partial output. The final <code>CodeExecutionResult</code> still contains the complete output.</p>"},{"location":"codeexec/#capturing-plots","title":"Capturing plots","text":"<p>Plots are automatically captured as PNG files in the <code>images</code> directory. Use <code>images_dir</code> to customize the location:</p> <pre><code>code = \"\"\"\nimport matplotlib.pyplot as plt\nplt.plot([1, 2, 3], [1, 4, 9])\nplt.show()\n\"\"\"\nwith tempfile.TemporaryDirectory() as images_dir:\n    async with CodeExecutor(images_dir=Path(images_dir)) as executor:\n        result = await executor.execute(code)\n        assert len(result.images) == 1\n        assert result.images[0].exists()\n        assert result.images[0].suffix == \".png\"\n</code></pre> <p>Generated images are available in <code>result.images</code> as a list of <code>Path</code> objects.</p>"},{"location":"codeexec/#custom-timeouts","title":"Custom timeouts","text":"<p>Configure approval and execution timeouts:</p> <pre><code># set custom approval timeout, default is no timeout\nasync with CodeExecutor(approval_timeout=10) as executor:\n    # set custom execution timeout, default is no timeout\n    async for item in executor.stream(\"...\", timeout=10):\n        ...\n</code></pre> <ul> <li><code>approval_timeout</code>: How long to wait for <code>accept()</code>/<code>reject()</code> (default: no timeout)</li> <li><code>timeout</code> in <code>stream()</code>: Maximum total execution time including approval waits (default: no timeout)</li> </ul>"},{"location":"codeexec/#kernel-environment","title":"Kernel environment","text":"<p>The IPython kernel does not inherit environment variables from the parent process. You can pass them explicitly with <code>kernel_env</code>:</p> <pre><code># IPython kernel does not inherit environment variables from parent process\n# Kernel environment must be explicitly set using the kernel_env parameter\nasync with CodeExecutor(kernel_env={\"TEST_VAR\": \"test_val\"}) as executor:\n    result = await executor.execute(\"import os; print(os.environ['TEST_VAR'])\")\n    assert result.text == \"test_val\"\n</code></pre> <p>Note</p> <p>Environment variables referenced in <code>server_params</code> via <code>${VAR_NAME}</code> are taken from the parent process and do not need to be passed to <code>kernel_env</code>.</p>"},{"location":"codeexec/#kernel-reset","title":"Kernel reset","text":"<p>Clear all variables and definitions by resetting the IPython kernel with <code>reset()</code>:</p> <pre><code>async with CodeExecutor() as executor:\n    await executor.execute(\"x = 42\")\n    result = await executor.execute(\"print(x)\")\n    assert result.text == \"42\"\n\n    await executor.reset()\n\n    code = \"\"\"\n    try:\n        print(x)\n    except NameError:\n        print(\"x not defined\")\n    \"\"\"\n    result = await executor.execute(code)\n    assert result.text == \"x not defined\"\n</code></pre> <p>This also stops any MCP servers started during execution. They restart lazily on their next tool call.</p>"},{"location":"codeexec/#working-directory","title":"Working directory","text":"<p>The kernel shares the working directory with the parent process:</p> <pre><code>async with CodeExecutor() as executor:\n    import os\n\n    result = await executor.execute(\"import os; print(os.getcwd())\")\n    assert result.text == os.getcwd()\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python-package","title":"Python package","text":"<p>Install ipybox using <code>pip</code>:</p> <pre><code>pip install ipybox\n</code></pre> <p>or <code>uv</code>:</p> <pre><code>uv add ipybox\n</code></pre>"},{"location":"installation/#mcp-server","title":"MCP server","text":"<p>ipybox can also be run as an MCP server using <code>uvx</code>:</p> <pre><code>uvx ipybox --workspace /path/to/workspace\n</code></pre> <p>See the MCP server documentation for configuration details.</p>"},{"location":"installation/#sandbox-runtime","title":"sandbox-runtime","text":"<p>To use ipybox's sandboxing features, you need to install Anthropic's sandbox-runtime separately. This provides the <code>srt</code> command for IPython kernel and MCP server isolation.</p> <p>Install via npm:</p> <pre><code>npm install -g @anthropic-ai/sandbox-runtime@0.0.21\n</code></pre>"},{"location":"installation/#mac-os","title":"Mac OS","text":"<p>On Mac OS, <code>sandbox-runtime</code> requires <code>ripgrep</code>. Install it using Homebrew:</p> <pre><code>brew install ripgrep\n</code></pre> <p>No other dependencies are needed on Mac OS, as <code>sandbox-runtime</code> uses the native <code>sandbox-exec</code> command for sandboxing.</p>"},{"location":"installation/#linux","title":"Linux","text":"<p>On Linux, install the required system packages:</p> <pre><code>apt-get install bubblewrap socat ripgrep\n</code></pre> <p>Info</p> <p>Sandboxing with <code>srt</code> currently doesn't work with ipybox on Linux, a fix is work in progress. You can still use ipybox on Linux with <code>sandbox=False</code>, or run the ipybox MCP server as a Docker container.</p>"},{"location":"mcpserver/","title":"MCP server","text":"<p>ipybox is a Python code execution sandbox with first-class support for programmatic MCP tool calling. Code executes in a sandboxed IPython Kernel, providing a stateful environment where variables and definitions persist across executions. </p> <p>When run as an MCP server, it exposes these capabilities to MCP clients like Claude Code or Claude Desktop. Agents can register MCP servers, then execute Python code that uses them programmatically:</p> <ol> <li>Agent calls <code>register_mcp_server</code> to generate a typed Python API for the tools of an MCP server</li> <li>Agent calls <code>execute_ipython_cell</code> to execute Python code that imports and uses the generated API</li> </ol> <p>Application example</p> <p>An application example of this MCP server is the programmatic tool calling plugin for Claude Code.</p>"},{"location":"mcpserver/#configuration","title":"Configuration","text":"<pre><code>{\n  \"mcpServers\": {\n    \"ipybox\": {\n      \"command\": \"uvx\",\n      \"args\": [\n        \"ipybox\",\n        \"--workspace\",\n        \"/path/to/workspace\"\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"mcpserver/#workspace","title":"Workspace","text":"<p>The <code>--workspace</code> option specifies the ipybox working directory, default is <code>\".\"</code>. Generated Python tool APIs are written to <code>mcptools/</code> in the workspace, and code execution use the workspace as working directory.</p>"},{"location":"mcpserver/#environment-variables","title":"Environment variables","text":"<p>Environment variables can be passed to ipybox either via an <code>\"env\"</code> key in the MCP configuration or in an <code>.env</code> file in the workspace directory:</p> /path/to/workspace/.env<pre><code>API_KEY_1=...\nAPI_KEY_2=...\nKERNEL_ENV_SECRET_1=...\nKERNEL_ENV_SECRET_2=...\n</code></pre> <p>These variables are available to MCP servers registered with ipybox but are not passed to the IPython kernel by default. To make them available to the kernel, use the <code>KERNEL_ENV_</code> prefix. For example, <code>KERNEL_ENV_SECRET_1</code> is available as <code>SECRET_1</code> in the kernel. </p>"},{"location":"mcpserver/#usage-example","title":"Usage example","text":"<p>This example shows a typical workflow using the Brave Search MCP server. First, configure the ipybox MCP server with a BRAVE_API_KEY:</p> <pre><code>{\n  \"mcpServers\": {\n    \"ipybox\": {\n      \"command\": \"uvx\",\n      \"args\": [\"ipybox\", \"--workspace\", \"/path/to/workspace\"],\n      \"env\": {\n        \"BRAVE_API_KEY\": \"your-api-key\"\n      }\n    }\n  }\n}\n</code></pre> <p>or add the API key to a <code>.env</code> file in the workspace directory:</p> /path/to/workspace/.env<pre><code>BRAVE_API_KEY=your-api-key\n</code></pre> <p>An agent then registers the Brave Search MCP server by calling <code>register_mcp_server</code> with the following argument:</p> <pre><code>{\n  \"server_name\": \"brave_search\",\n  \"server_params\": {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@anthropic/mcp-server-brave-search\"],\n    \"env\": {\"BRAVE_API_KEY\": \"${BRAVE_API_KEY}\"}\n  }\n}\n</code></pre> <p>The <code>${BRAVE_API_KEY}</code> placeholder is replaced with the actual value from the MCP configuration or the <code>.env</code> file. ipybox connects to the Brave Search MCP server and generates a Python tool API under <code>mcptools/brave_search/</code>. </p> <p>After registration, the agent calls <code>execute_ipython_cell</code> with Python code that uses the generated API:</p> <pre><code>from mcptools.brave_search.brave_web_search import Params, run\n\nresult = run(Params(query=\"Python asyncio tutorial\", count=3))\nprint(result)\n</code></pre> <p>The printed result is returned and added to the agent's context window.</p>"},{"location":"mcpserver/#tools","title":"Tools","text":"<p>The ipybox MCP server exposes four tools.</p>"},{"location":"mcpserver/#register_mcp_server","title":"<code>register_mcp_server</code>","text":"<p>Connects to an MCP server and generates a Python API for its tools under <code>mcptools/{server_name}/</code>.</p> <p>Parameters:</p> <ul> <li><code>server_name</code> \u2014 Application-defined MCP server name (valid Python identifier)</li> <li><code>server_params</code> \u2014 Server config: <code>{\"command\", \"args\", \"env\"}</code> for stdio or <code>{\"url\", \"headers\"}</code> for HTTP</li> </ul>"},{"location":"mcpserver/#execute_ipython_cell","title":"<code>execute_ipython_cell</code>","text":"<p>Executes Python code in a stateful IPython kernel. Executed code can use the generated Python tool API of registered MCP servers. MCP tool calls from executed code are auto-approved.</p> <p>Parameters:</p> <ul> <li><code>code</code> \u2014 Python code to execute</li> <li><code>timeout</code> \u2014 Maximum execution time in seconds (default: no timeout)</li> <li><code>max_output_chars</code> \u2014 Output character limit (default: 5000)</li> </ul> <p>Returns the execution output.</p>"},{"location":"mcpserver/#install_package","title":"<code>install_package</code>","text":"<p>Installs a Python package via <code>pip</code>. Supports version specifiers and git URLs.</p> <p>Parameters:</p> <ul> <li><code>package_name</code> \u2014 Package spec (e.g., <code>requests</code>, <code>numpy&gt;=1.20.0</code>, or <code>git+https://...</code>)</li> </ul>"},{"location":"mcpserver/#reset","title":"<code>reset</code>","text":"<p>Creates a new kernel, clearing all variables and imports. Installed packages and generated <code>mcptools/</code> persist.</p>"},{"location":"mcpserver/#sandboxing","title":"Sandboxing","text":"<p>To isolate code execution via Anthropic's sandbox-runtime, enable sandboxing with the <code>--sandbox</code> option:</p> <pre><code>{\n  \"mcpServers\": {\n    \"ipybox\": {\n      \"command\": \"uvx\",\n      \"args\": [\n        \"ipybox\",\n        \"--workspace\",\n        \"/path/to/workspace\",\n        \"--sandbox\",\n        \"--sandbox-config\",\n        \"/path/to/sandbox-config.json\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The default sandbox configuration permits reading all files except <code>.env</code> and writing to the current directory and subdirectories (plus IPython directories). Access to internet is blocked. An optional custom sandbox configuration can be passed with the <code>--sandbox-config</code> option.</p> <p>Info</p> <p>Sandboxing with sandbox-runtime currently works on Mac OS only. On Linux and Windows, you can either run ipybox without sandboxing or as a Docker container.</p>"},{"location":"mcpserver/#docker","title":"Docker","text":"<p>ipybox can be run as a Docker container. Clone the project and build the image:</p> <pre><code>git clone https://github.com/gradion-ai/ipybox.git\ncd ipybox\n./docker-build.sh\n</code></pre> <p>The build script creates a container user with your UID/GID, ensuring files generated by ipybox in the mounted workspace are owned by you and can be edited on the host.</p> <p>Then configure the MCP server:</p> <pre><code>{\n  \"mcpServers\": {\n    \"ipybox\": {\n      \"command\": \"docker\",\n      \"args\": [\n        \"run\",\n        \"-i\",\n        \"--rm\",\n        \"-v\",\n        \"/path/to/workspace:/app/workspace\",\n        \"ipybox\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The workspace <code>/path/to/workspace</code> on the host is mounted to <code>/app/workspace</code> inside the container.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide walks through a complete example: generating a Python tool API for the Brave Search MCP server, executing code that calls it, and handling tool call approvals.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install ipybox\n</code></pre>"},{"location":"quickstart/#get-a-brave-api-key","title":"Get a Brave API key","text":"<p>Sign up for a free API key at api.search.brave.com. Once you have your key, set it as an environment variable:</p> <pre><code>export BRAVE_API_KEY=your_api_key_here\n</code></pre> <p>Or create a <code>.env</code> file in your project root (ipybox loads it automatically):</p> <pre><code>BRAVE_API_KEY=your_api_key_here\n</code></pre>"},{"location":"quickstart/#complete-example","title":"Complete example","text":"<pre><code>import asyncio\nfrom pathlib import Path\n\nfrom ipybox import ApprovalRequest, CodeExecutionResult, CodeExecutor, generate_mcp_sources\nfrom ipybox.utils import arun\n\nSERVER_PARAMS = {\n    \"command\": \"npx\",\n    \"args\": [\n        \"-y\",\n        \"@brave/brave-search-mcp-server\",\n        \"--transport\",\n        \"stdio\",\n    ],\n    \"env\": {\n        \"BRAVE_API_KEY\": \"${BRAVE_API_KEY}\",\n    },\n}\n\nCODE = \"\"\"\nfrom mcptools.brave_search.brave_image_search import Params, Result, run\n\nresult: Result = run(Params(query=\"neural topic models\", count=3))\n\nfor image in result.items:\n    print(f\"- [{image.title}]({image.properties.url})\")\n\"\"\"\n\n\nasync def main():\n    # Generate a Python tool API\n    # for the Brave Search MCP server\n    await generate_mcp_sources(\n        server_name=\"brave_search\",\n        server_params=SERVER_PARAMS,\n        root_dir=Path(\"mcptools\"),\n    )\n\n    # Launch ipybox code executor\n    async with CodeExecutor() as executor:\n        # Execute code that calls an MCP tool\n        # programmatically in an IPython kernel\n        async for item in executor.stream(CODE):\n            match item:\n                # Handle approval requests\n                case ApprovalRequest() as req:\n                    # Prompt user to approve or reject MCP tool call\n                    prompt = f\"Tool call: [{req}]\\nApprove? (Y/n): \"\n                    if await arun(input, prompt) in [\"y\", \"\"]:\n                        await req.accept()\n                    else:\n                        await req.reject()\n                # Handle final execution result\n                case CodeExecutionResult(text=text):\n                    print(text)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#how-it-works","title":"How it works","text":""},{"location":"quickstart/#server-parameters","title":"Server parameters","text":"<p>The <code>server_params</code> dict defines how to connect to an MCP server. For stdio servers (local processes), you specify:</p> <ul> <li><code>command</code>: The executable to run</li> <li><code>args</code>: Command-line arguments</li> <li><code>env</code>: Environment variables to pass</li> </ul> <pre><code>SERVER_PARAMS = {\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@brave/brave-search-mcp-server\", \"--transport\", \"stdio\"],\n    \"env\": {\"BRAVE_API_KEY\": \"${BRAVE_API_KEY}\"},\n}\n</code></pre> <p>The <code>${BRAVE_API_KEY}</code> placeholder is replaced with the actual value from your environment when ipybox starts the MCP server.</p>"},{"location":"quickstart/#generating-a-python-tool-api","title":"Generating a Python tool API","text":"<p><code>generate_mcp_sources()</code> connects to the MCP server, discovers its tools, and generates a typed Python API from their schema:</p> <pre><code>await generate_mcp_sources(\n    server_name=\"brave_search\",\n    server_params=SERVER_PARAMS,\n    root_dir=Path(\"mcptools\"),\n)\n</code></pre> <p>This creates an <code>mcptools/brave_search</code> package with a Python module for each MCP server tool:</p> <pre><code>mcptools/brave_search/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 brave_web_search.py\n\u251c\u2500\u2500 brave_local_search.py\n\u251c\u2500\u2500 brave_image_search.py\n\u2514\u2500\u2500 ...\n</code></pre> <p>Each module contains a Pydantic <code>Params</code> class for input validation, a <code>Result</code> class or <code>str</code> return type, and a <code>run()</code> function that executes the MCP tool.</p>"},{"location":"quickstart/#code-execution","title":"Code execution","text":"<p><code>CodeExecutor</code> runs Python code in an IPython kernel. Variables and definitions persist across executions, enabling stateful workflows.</p> <pre><code>async with CodeExecutor() as executor:\n    async for item in executor.stream(CODE):\n        ...\n</code></pre> <p>The <code>stream()</code> method yields events as execution progresses. You'll receive <code>ApprovalRequest</code> events when the code calls an MCP tool, and a final <code>CodeExecutionResult</code> with the output.</p>"},{"location":"quickstart/#tool-call-approval","title":"Tool call approval","text":"<p>When an MCP tool is called during code execution, ipybox pauses execution and sends an <code>ApprovalRequest</code> to your application. You must explicitly approve or reject each tool call:</p> <pre><code>case ApprovalRequest() as req:\n    if user_approves:\n        await req.accept()\n    else:\n        await req.reject()\n</code></pre> <p>The <code>ApprovalRequest</code> includes the server name, tool name, and arguments, so you can make informed decisions or implement custom approval logic.</p>"},{"location":"quickstart/#next-steps","title":"Next steps","text":"<ul> <li>API Generation - Generating typed Python APIs from MCP tools</li> <li>Code Execution - Running code and handling tool approvals</li> <li>Sandboxing - Secure execution with network and filesystem isolation</li> </ul>"},{"location":"sandbox/","title":"Sandboxing","text":"<p>ipybox uses Anthropic's sandbox-runtime to isolate code execution. When enabled, the IPython kernel runs with restricted filesystem and network access.</p> <pre><code>from ipybox import CodeExecutionError, CodeExecutor, generate_mcp_sources\n</code></pre>"},{"location":"sandbox/#default-sandbox","title":"Default sandbox","text":"<p>Enable sandboxing with <code>sandbox=True</code>.</p> <pre><code>async with CodeExecutor(sandbox=True) as executor:\n    result = await executor.execute(\"print('hello world')\")\n    assert result.text == \"hello world\"\n\n    code = \"\"\"\n    import requests\n    try:\n        requests.get('https://example.org')\n    except Exception as e:\n        print(e)\n    \"\"\"\n\n    # Default sandbox config blocks internet access\n    result = await executor.execute(code)\n    assert \"Failed to resolve 'example.org'\" in result.text\n</code></pre> <p>The default sandbox configuration allows:</p> <ul> <li>Reading all files except <code>.env</code></li> <li>Writing to the current directory and subdirectories (plus IPython directories)</li> <li>Local network access to the tool execution server</li> </ul> Default sandbox configuration<pre><code>{\n  \"enableWeakerNestedSandbox\": false,\n  \"filesystem\": {\n    \"denyRead\": [\".env\"],\n    \"allowWrite\": [\".\", \"~/Library/Jupyter\", \"~/.ipython\"],\n    \"denyWrite\": []\n  },\n  \"network\": {\n    \"allowedDomains\": [],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  }\n}\n</code></pre> <p>Internet access is blocked as demonstrated in the example above. See the sandbox-runtime documentation for all configuration options.</p>"},{"location":"sandbox/#custom-sandbox","title":"Custom sandbox","text":"<p>To allow access to <code>example.org</code>, provide a custom sandbox configuration file:</p> examples/sandbox-kernel.json<pre><code>{\n    \"enableWeakerNestedSandbox\": false,\n    \"filesystem\": {\n      \"denyRead\": [\".env\"],\n      \"allowWrite\": [\".\", \"~/Library/Jupyter\", \"~/.ipython\"],\n      \"denyWrite\": []\n    },\n    \"network\": {\n      \"allowedDomains\": [\"example.org\"],\n      \"deniedDomains\": [],\n      \"allowLocalBinding\": true\n    }\n  }\n</code></pre> <p>and pass it as <code>sandbox_config</code> argument:</p> <pre><code>code = \"\"\"\nimport requests\nresult = requests.get('https://example.org')\nprint(result.text)\n\"\"\"\nasync with CodeExecutor(\n    sandbox=True,\n    sandbox_config=Path(\"examples/sandbox-kernel.json\"),\n    log_level=\"WARNING\",\n) as executor:\n    result = await executor.execute(code)\n    assert \"Example Domain\" in result.text\n</code></pre>"},{"location":"sandbox/#sandboxing-mcp-servers","title":"Sandboxing MCP servers","text":"<p>stdio MCP servers like the filesystem MCP server can be configured to run in a sandbox using <code>srt</code> as command:</p> <pre><code>server_params = {\n    \"command\": \"srt\",\n    \"args\": [\n        \"--settings\",\n        \"examples/sandbox-mcp.json\",\n        \"npx\",\n        \"-y\",\n        \"@modelcontextprotocol/server-filesystem\",\n        \".\",\n    ],\n}\n</code></pre> <p>The sandbox configuration is:</p> examples/sandbox-mcp.json<pre><code>{\n    \"enableWeakerNestedSandbox\": false,\n    \"filesystem\": {\n      \"denyRead\": [\".env\"],\n      \"allowWrite\": [\".\", \"~/.npm\"],\n      \"denyWrite\": []\n    },\n    \"network\": {\n      \"allowedDomains\": [\"registry.npmjs.org\"],\n      \"deniedDomains\": [],\n      \"allowLocalBinding\": true\n    }\n  }\n</code></pre> <p>The server itself is configured with permissions to access all files in the current directory (<code>\".\"</code>), but the sandbox additionally blocks read access to <code>.env</code>. The sandbox also allows access to <code>registry.npmjs.org</code> for downloading the server package via <code>npx</code>, and <code>~/.npm</code> for the local <code>npm</code> cache.</p> <pre><code>await generate_mcp_sources(\"filesystem\", server_params, Path(\"mcptools\"))\n\nlist_dir_code = \"\"\"\nfrom mcptools.filesystem.list_directory import run, Params\nresult = run(Params(path=\".\"))\nprint(result.content)\n\"\"\"\n\nread_env_code = \"\"\"\nfrom mcptools.filesystem.read_file import run, Params\nresult = run(Params(path=\".env\"))\nprint(result.content)\n\"\"\"\n\nasync with CodeExecutor(sandbox=True) as executor:\n    # allowed by MCP server and sandbox\n    result = await executor.execute(list_dir_code)\n    assert \"README.md\" in result.text\n\n    try:\n        # allowed by MCP server but blocked by sandbox\n        result = await executor.execute(read_env_code)\n        assert False, \"Read access to .env not blocked\"\n    except CodeExecutionError as e:\n        assert \"operation not permitted\" in str(e)\n</code></pre> <p>Info</p> <p>MCP server sandboxing is independent of kernel sandboxing and usually not needed when using trusted servers, but provides an additional security layer when needed. </p>"},{"location":"api/code_executor/","title":"Code Executor","text":""},{"location":"api/code_executor/#ipybox.CodeExecutor","title":"ipybox.CodeExecutor","text":"<pre><code>CodeExecutor(\n    tool_server_host: str = \"localhost\",\n    tool_server_port: int | None = None,\n    kernel_gateway_host: str = \"localhost\",\n    kernel_gateway_port: int | None = None,\n    kernel_env: dict[str, str] | None = None,\n    images_dir: Path | None = None,\n    approval_timeout: float | None = None,\n    connect_timeout: float = 30,\n    sandbox: bool = False,\n    sandbox_config: Path | None = None,\n    log_level: str = \"WARNING\",\n)\n</code></pre> <p>Executes Python code in an IPython kernel with programmatic MCP tool call support.</p> <p><code>CodeExecutor</code> launches an embedded <code>KernelGateway</code> for running Python code and an embedded <code>ToolServer</code> for executing MCP tools. Code is executed in an IPython kernel, providing a stateful environment where variables and definitions persist across executions.</p> <p>MCP tools can be called from executed code using the API generated by <code>generate_mcp_sources</code>. When code calls an MCP tool, the tool server receives the request and emits an approval request. The client must accept or reject the request before the tool executes.</p> Example <p>Generate a Python tool API and execute code that uses it:</p> <pre><code>from pathlib import Path\n\nfrom ipybox import ApprovalRequest, CodeExecutionResult, CodeExecutor\nfrom ipybox import generate_mcp_sources\n\n# Generate a Python tool API for the fetch MCP server\nserver_params = {\"command\": \"uvx\", \"args\": [\"mcp-server-fetch\"]}\nawait generate_mcp_sources(\"fetch\", server_params, Path(\"mcptools\"))\n\n# Execute code that calls the generated API\ncode = \"\"\"\nfrom mcptools.fetch import fetch\n\nresult = fetch.run(fetch.Params(url=\"https://example.com\"))\nprint(result)\n\"\"\"\n\nasync with CodeExecutor() as executor:\n    async for item in executor.stream(code):\n        match item:\n            case ApprovalRequest():\n                print(f\"Tool call: {item}\")\n                await item.accept()\n            case CodeExecutionResult():\n                print(item.text)\n</code></pre> <p>Configure a code executor with optional sandboxing.</p> <p>Parameters:</p> Name Type Description Default <code>tool_server_host</code> <code>str</code> <p>Hostname for the <code>ToolServer</code>.</p> <code>'localhost'</code> <code>tool_server_port</code> <code>int | None</code> <p>Port for the tool server. If <code>None</code>, a free port is selected automatically.</p> <code>None</code> <code>kernel_gateway_host</code> <code>str</code> <p>Hostname for the <code>KernelGateway</code>.</p> <code>'localhost'</code> <code>kernel_gateway_port</code> <code>int | None</code> <p>Port for the kernel gateway. If <code>None</code>, a free port is selected automatically.</p> <code>None</code> <code>kernel_env</code> <code>dict[str, str] | None</code> <p>Environment variables to set for the IPython kernel. Kernels do not inherit environment variables from the parent process.</p> <code>None</code> <code>images_dir</code> <code>Path | None</code> <p>Directory for saving images generated during code execution. Defaults to <code>images</code> in the current directory.</p> <code>None</code> <code>approval_timeout</code> <code>float | None</code> <p>Timeout in seconds for approval requests. If an approval request is not accepted or rejected within this time, the tool call fails. If <code>None</code>, no timeout is applied.</p> <code>None</code> <code>connect_timeout</code> <code>float</code> <p>Timeout in seconds for starting MCP servers.</p> <code>30</code> <code>sandbox</code> <code>bool</code> <p>Whether to run the kernel gateway inside Anthropic's sandbox-runtime. When enabled, IPython kernels run in a secure sandbox with no network access except to the local tool server.</p> <code>False</code> <code>sandbox_config</code> <code>Path | None</code> <p>Path to a JSON file with sandbox configuration. See the Configuration section of the sandbox-runtime README for available options.</p> <code>None</code> <code>log_level</code> <code>str</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> <code>'WARNING'</code>"},{"location":"api/code_executor/#ipybox.CodeExecutor.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(\n    code: str, timeout: float | None = None\n) -&gt; CodeExecutionResult\n</code></pre> <p>Execute Python code with automatic approval of all MCP tool calls.</p> <p>Convenience method that executes code, auto-approves any MCP tool calls, and returns the final result directly.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to execute.</p> required <code>timeout</code> <code>float | None</code> <p>Maximum time in seconds to wait for execution to complete. If <code>None</code>, no timeout is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>CodeExecutionResult</code> <p>The execution result containing output text and generated images.</p> <p>Raises:</p> Type Description <code>CodeExecutionError</code> <p>If code execution raises an error.</p> <code>TimeoutError</code> <p>If code execution exceeds the timeout.</p>"},{"location":"api/code_executor/#ipybox.CodeExecutor.reset","title":"reset  <code>async</code>","text":"<pre><code>reset()\n</code></pre> <p>Reset execution state.</p> <p>Restarts the IPython kernel and stops all started MCP servers. Kernel state (variables, definitions, imports) is lost. MCP servers are lazily restarted on their next tool call.</p>"},{"location":"api/code_executor/#ipybox.CodeExecutor.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the executor.</p> <p>Starts the tool server, kernel gateway, and connects to the IPython kernel.</p>"},{"location":"api/code_executor/#ipybox.CodeExecutor.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop the executor.</p> <p>Stops the tool server, kernel gateway, and disconnects from the IPython kernel.</p>"},{"location":"api/code_executor/#ipybox.CodeExecutor.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(\n    code: str,\n    timeout: float | None = None,\n    chunks: bool = False,\n) -&gt; AsyncIterator[\n    ApprovalRequest\n    | CodeExecutionChunk\n    | CodeExecutionResult\n]\n</code></pre> <p>Execute Python code in the IPython kernel with MCP tool call approval.</p> <p>Code can call MCP tools using the API generated by <code>generate_mcp_sources</code>. Each tool call yields an <code>ApprovalRequest</code>. If accepted, the tool executes on the <code>ToolServer</code> and returns the result to the kernel. If rejected, the tool call fails with an error.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to execute.</p> required <code>timeout</code> <code>float | None</code> <p>Maximum time in seconds to wait for execution to complete. If <code>None</code>, no timeout is applied.</p> <code>None</code> <code>chunks</code> <code>bool</code> <p>Whether to yield <code>CodeExecutionChunk</code> objects during execution. When <code>False</code>, only <code>ApprovalRequest</code> and <code>CodeExecutionResult</code> are yielded.</p> <code>False</code> <p>Yields:</p> Type Description <code>AsyncIterator[ApprovalRequest | CodeExecutionChunk | CodeExecutionResult]</code> <p><code>ApprovalRequest</code>: When executed code calls an MCP tool. Accept to execute the tool, reject to fail the tool call.</p> <code>AsyncIterator[ApprovalRequest | CodeExecutionChunk | CodeExecutionResult]</code> <p><code>CodeExecutionChunk</code>: Output text chunks generated during execution (emitted only if <code>chunks=True</code>).</p> <code>AsyncIterator[ApprovalRequest | CodeExecutionChunk | CodeExecutionResult]</code> <p><code>CodeExecutionResult</code>: The final result when execution completes successfully.</p> <p>Raises:</p> Type Description <code>CodeExecutionError</code> <p>If code execution raises an error (syntax errors, runtime errors, rejected or timed-out approval requests, MCP tool errors). The error message contains the stack trace from the kernel.</p> <code>TimeoutError</code> <p>If code execution exceeds the timeout.</p>"},{"location":"api/code_executor/#ipybox.CodeExecutionChunk","title":"ipybox.CodeExecutionChunk  <code>dataclass</code>","text":"<pre><code>CodeExecutionChunk(text: str)\n</code></pre> <p>A chunk of output text generated during streaming code execution.</p> <p>Only yielded by <code>CodeExecutor.stream</code> when <code>chunks=True</code>.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>A chunk of output text.</p>"},{"location":"api/code_executor/#ipybox.CodeExecutionResult","title":"ipybox.CodeExecutionResult  <code>dataclass</code>","text":"<pre><code>CodeExecutionResult(text: str | None, images: list[Path])\n</code></pre> <p>The result of a successful code execution.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str | None</code> <p>Output text generated during execution, or <code>None</code> if no output.</p> <code>images</code> <code>list[Path]</code> <p>Paths to images generated during execution.</p>"},{"location":"api/code_executor/#ipybox.CodeExecutionError","title":"ipybox.CodeExecutionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when code execution in an IPython kernel fails.</p>"},{"location":"api/code_executor/#ipybox.generate_mcp_sources","title":"ipybox.generate_mcp_sources  <code>async</code>","text":"<pre><code>generate_mcp_sources(\n    server_name: str,\n    server_params: dict[str, Any],\n    root_dir: Path,\n) -&gt; list[str]\n</code></pre> <p>Generate a typed Python tool API for an MCP server.</p> <p>Connects to an MCP server, discovers available tools, and generates a Python package with typed functions backed by Pydantic models. Each tool becomes a module with a <code>Params</code> class for input validation and a <code>run()</code> function to invoke the tool.</p> <p>When calling the generated API, the corresponding tools are executed on a <code>ToolServer</code>.</p> <p>If a directory for the server already exists under <code>root_dir</code>, it is removed and recreated.</p> <p>Parameters:</p> Name Type Description Default <code>server_name</code> <code>str</code> <p>Name for the generated package directory. Also used to identify the server in the generated client code.</p> required <code>server_params</code> <code>dict[str, Any]</code> <p>MCP server connection parameters. For stdio servers, provide <code>command</code>, <code>args</code>, and optionally <code>env</code>. For HTTP servers, provide <code>url</code> and optionally <code>headers</code>.</p> required <code>root_dir</code> <code>Path</code> <p>Parent directory where the package will be created. The generated package is written to <code>root_dir/server_name/</code>.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of sanitized tool names corresponding to the generated module files.</p> Example <p>Generate a Python tool API for the fetch MCP server:</p> <pre><code>server_params = {\n    \"command\": \"uvx\",\n    \"args\": [\"mcp-server-fetch\"],\n}\nawait generate_mcp_sources(\"fetch_mcp\", server_params, Path(\"mcptools\"))\n</code></pre> <p>Execute code that uses the generated API:</p> <pre><code>from ipybox.code_exec import CodeExecutor\n\ncode = \"\"\"\nfrom mcptools.fetch_mcp import fetch\n\nresult = fetch.run(fetch.Params(url=\"https://example.com\"))\nprint(result)\n\"\"\"\n\nasync with CodeExecutor() as executor:\n    async for item in executor.execute(code):\n        ...\n</code></pre>"},{"location":"api/kernel_manager/","title":"Kernel Manager","text":""},{"location":"api/kernel_manager/#ipybox.kernel_mgr.server.KernelGateway","title":"ipybox.kernel_mgr.server.KernelGateway","text":"<pre><code>KernelGateway(\n    host: str = \"localhost\",\n    port: int = 8888,\n    sandbox: bool = False,\n    sandbox_config: Path | None = None,\n    log_level: str = \"INFO\",\n    log_to_stderr: bool = False,\n    env: dict[str, str] | None = None,\n)\n</code></pre> <p>Manages a Jupyter Kernel Gateway process.</p> <p>The kernel gateway provides a REST and WebSocket API for creating and communicating with IPython kernels. Use <code>KernelClient</code> to create and connect to an IPython kernel and execute code.</p> <p>When sandboxing is enabled, the gateway runs inside Anthropic's sandbox-runtime, providing secure isolation for code execution.</p> Example <pre><code>async with KernelGateway(host=\"localhost\", port=8888) as gateway:\n    # Gateway is running, connect with KernelClient\n    await gateway.join()  # Wait until gateway stops\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname or IP address to bind the gateway to.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Port number the gateway listens on.</p> <code>8888</code> <code>sandbox</code> <code>bool</code> <p>Whether to run the gateway inside the sandbox-runtime.</p> <code>False</code> <code>sandbox_config</code> <code>Path | None</code> <p>Path to a JSON file with sandbox configuration. See the Configuration section of the sandbox-runtime README for available options.</p> <code>None</code> <code>log_level</code> <code>str</code> <p>Logging level for the gateway process.</p> <code>'INFO'</code> <code>log_to_stderr</code> <code>bool</code> <p>Whether to redirect gateway logs to stderr.</p> <code>False</code> <code>env</code> <code>dict[str, str] | None</code> <p>Environment variables to set for kernels created by the gateway. Kernels do not inherit environment variables from the parent process, so any required variables must be explicitly provided.</p> <code>None</code>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.server.KernelGateway.join","title":"join  <code>async</code>","text":"<pre><code>join()\n</code></pre> <p>Waits for the kernel gateway process to exit.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.server.KernelGateway.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Starts the kernel gateway process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the gateway is already running.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.server.KernelGateway.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(timeout: float = 10)\n</code></pre> <p>Stops the kernel gateway process.</p> <p>Terminates the gateway and all child processes. If the process doesn't stop within the timeout, it is forcefully killed.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time in seconds to wait for graceful termination.</p> <code>10</code>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.KernelClient","title":"ipybox.kernel_mgr.client.KernelClient","text":"<pre><code>KernelClient(\n    host: str = \"localhost\",\n    port: int = 8888,\n    images_dir: Path | None = None,\n    ping_interval: float = 10,\n)\n</code></pre> <p>Client for executing code in an IPython kernel.</p> <p>Connects to a <code>KernelGateway</code> to create and communicate with an IPython kernel. Code execution is stateful: definitions and variables from previous executions are available to subsequent executions.</p> Example <pre><code>async with KernelClient(host=\"localhost\", port=8888) as client:\n    # Simple execution\n    result = await client.execute(\"print('hello')\")\n    print(result.text)\n\n    # Streaming execution\n    async for item in client.stream(\"print('hello')\"):\n        match item:\n            case str():\n                print(f\"Chunk: {item}\")\n            case ExecutionResult():\n                print(f\"Result: {item}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname or IP address of the kernel gateway.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Port number of the kernel gateway.</p> <code>8888</code> <code>images_dir</code> <code>Path | None</code> <p>Directory for saving images generated during code execution. Defaults to <code>images</code> in the current directory.</p> <code>None</code> <code>ping_interval</code> <code>float</code> <p>Interval in seconds for WebSocket pings that keep the connection to the IPython kernel alive.</p> <code>10</code>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.KernelClient.kernel_id","title":"kernel_id  <code>property</code>","text":"<pre><code>kernel_id\n</code></pre> <p>The ID of the running IPython kernel.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If not connected to a kernel.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.KernelClient.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(retries: int = 10, retry_interval: float = 1.0)\n</code></pre> <p>Creates an IPython kernel and connects to it.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>Number of connection retries.</p> <code>10</code> <code>retry_interval</code> <code>float</code> <p>Delay between connection retries in seconds.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If connection cannot be established after all retries.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.KernelClient.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnects from and deletes the running IPython kernel.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.KernelClient.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(\n    code: str, timeout: float | None = None\n) -&gt; ExecutionResult\n</code></pre> <p>Executes code in this client's IPython kernel and returns the result.</p> <p>Waits for execution to complete and returns the final result. Use <code>stream</code> for incremental output.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to execute.</p> required <code>timeout</code> <code>float | None</code> <p>Maximum time in seconds to wait for the execution result. If <code>None</code>, no timeout is applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>ExecutionResult</code> <p>The execution result containing output text and generated images.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If code execution raises an error.</p> <code>TimeoutError</code> <p>If code execution duration exceeds the timeout.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.KernelClient.reset","title":"reset  <code>async</code>","text":"<pre><code>reset()\n</code></pre> <p>Resets the IPython kernel to a clean state.</p> <p>Deletes the running kernel and creates a new one.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.KernelClient.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(\n    code: str, timeout: float | None = None\n) -&gt; AsyncIterator[str | ExecutionResult]\n</code></pre> <p>Executes code in this client's IPython kernel.</p> <p>Yields output chunks as strings during execution, and yields the final ExecutionResult as the last item.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to execute.</p> required <code>timeout</code> <code>float | None</code> <p>Maximum time in seconds to wait for the execution result. If <code>None</code>, no timeout is applied.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>str</code> <code>AsyncIterator[str | ExecutionResult]</code> <p>Output text chunks generated during execution.</p> <code>ExecutionResult</code> <code>AsyncIterator[str | ExecutionResult]</code> <p>The final result containing complete text and images.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If code execution raises an error.</p> <code>TimeoutError</code> <p>If code execution duration exceeds the timeout.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.ExecutionResult","title":"ipybox.kernel_mgr.client.ExecutionResult  <code>dataclass</code>","text":"<pre><code>ExecutionResult(text: str | None, images: list[Path])\n</code></pre> <p>The result of a successful code execution.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str | None</code> <p>Output text generated during execution.</p> <code>images</code> <code>list[Path]</code> <p>List of paths to images generated during execution.</p>"},{"location":"api/kernel_manager/#ipybox.kernel_mgr.client.ExecutionError","title":"ipybox.kernel_mgr.client.ExecutionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when code executed in an IPython kernel raises an error.</p>"},{"location":"api/tool_executor/","title":"Tool Executor","text":""},{"location":"api/tool_executor/#ipybox.tool_exec.server.ToolServer","title":"ipybox.tool_exec.server.ToolServer","text":"<pre><code>ToolServer(\n    host=\"localhost\",\n    port: int = 8900,\n    approval_required: bool = False,\n    approval_timeout: float | None = None,\n    connect_timeout: float = 30,\n    log_to_stderr: bool = False,\n    log_level: str = \"INFO\",\n)\n</code></pre> <p>HTTP server that manages MCP servers and executes their tools with optional approval.</p> <p>ToolServer provides HTTP endpoints for executing MCP tools and a WebSocket endpoint for sending approval requests to clients. MCP servers are started on demand when tools are first executed and cached for subsequent calls.</p> <p>Endpoints:</p> <ul> <li><code>PUT /reset</code>: Closes all started MCP servers</li> <li><code>POST /run</code>: Executes an MCP tool (with optional approval)</li> <li><code>WS /approval</code>: WebSocket endpoint for     <code>ApprovalClient</code> connections</li> </ul> Example <pre><code>async with ToolServer(approval_required=True) as server:\n    async with ApprovalClient(callback=on_approval_request):\n        # Execute code that calls MCP tools\n        ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>host</code> <p>Hostname the server binds to.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Port number the server listens on.</p> <code>8900</code> <code>approval_required</code> <code>bool</code> <p>Whether tool calls require approval.</p> <code>False</code> <code>approval_timeout</code> <code>float | None</code> <p>Timeout in seconds for approval requests. If <code>None</code>, no timeout is applied.</p> <code>None</code> <code>connect_timeout</code> <code>float</code> <p>Timeout in seconds for starting MCP servers.</p> <code>30</code> <code>log_to_stderr</code> <code>bool</code> <p>Whether to log to stderr instead of stdout.</p> <code>False</code> <code>log_level</code> <code>str</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> <code>'INFO'</code>"},{"location":"api/tool_executor/#ipybox.tool_exec.server.ToolServer.join","title":"join  <code>async</code>","text":"<pre><code>join()\n</code></pre> <p>Wait for the HTTP server task to stop.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.server.ToolServer.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the HTTP server.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the server is already running.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.server.ToolServer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop the HTTP server and close all managed MCP servers.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.client.ToolRunner","title":"ipybox.tool_exec.client.ToolRunner","text":"<pre><code>ToolRunner(\n    server_name: str,\n    server_params: dict[str, Any],\n    host: str = \"localhost\",\n    port: int = 8900,\n)\n</code></pre> <p>Client for executing MCP tools on a <code>ToolServer</code>.</p> Example <pre><code>runner = ToolRunner(\n    server_name=\"fetch\",\n    server_params={\"command\": \"uvx\", \"args\": [\"mcp-server-fetch\"]},\n)\nresult = await runner.run(\"fetch\", {\"url\": \"https://example.com\"})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>server_name</code> <code>str</code> <p>Name of the MCP server.</p> required <code>server_params</code> <code>dict[str, Any]</code> <p>MCP server parameters.</p> required <code>host</code> <code>str</code> <p>Hostname of the <code>ToolServer</code>.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Port number of the <code>ToolServer</code>.</p> <code>8900</code>"},{"location":"api/tool_executor/#ipybox.tool_exec.client.ToolRunner.reset","title":"reset  <code>async</code>","text":"<pre><code>reset()\n</code></pre> <p>Reset the <code>ToolServer</code>, stopping all started MCP servers.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.client.ToolRunner.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    tool_name: str, tool_args: dict[str, Any]\n) -&gt; dict[str, Any] | str | None\n</code></pre> <p>Execute a tool on the configured MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to execute.</p> required <code>tool_args</code> <code>dict[str, Any]</code> <p>Arguments to pass to the tool.</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | str | None</code> <p>The tool execution result.</p> <p>Raises:</p> Type Description <code>ToolRunnerError</code> <p>If tool execution fails or approval is denied.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.client.ToolRunner.run_sync","title":"run_sync","text":"<pre><code>run_sync(\n    tool_name: str, tool_args: dict[str, Any]\n) -&gt; dict[str, Any] | str | None\n</code></pre> <p>Synchronous version of <code>run</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to execute.</p> required <code>tool_args</code> <code>dict[str, Any]</code> <p>Arguments to pass to the tool.</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | str | None</code> <p>The tool execution result.</p> <p>Raises:</p> Type Description <code>ToolRunnerError</code> <p>If tool execution fails or approval is denied.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.client.ToolRunnerError","title":"ipybox.tool_exec.client.ToolRunnerError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when tool execution fails on the server or when approval is rejected.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.client.ApprovalClient","title":"ipybox.tool_exec.approval.client.ApprovalClient","text":"<pre><code>ApprovalClient(\n    callback: ApprovalCallback,\n    host: str = \"localhost\",\n    port: int = 8900,\n)\n</code></pre> <p>Client for handling tool call approval requests.</p> <p><code>ApprovalClient</code> connects to a <code>ToolServer</code>'s <code>ApprovalChannel</code> and receives approval requests. Each request is passed to the registered callback, which must accept or reject the request.</p> Example <pre><code>async def on_approval_request(request: ApprovalRequest):\n    print(f\"Approval request: {request}\")\n    await request.accept()\n\nasync with ApprovalClient(callback=on_approval_request):\n    # Execute code that triggers MCP tool calls\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>ApprovalCallback</code> <p>Async function called for each approval request.</p> required <code>host</code> <code>str</code> <p>Hostname of the <code>ToolServer</code>.</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Port number of the <code>ToolServer</code>.</p> <code>8900</code>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.client.ApprovalClient.connect","title":"connect  <code>async</code>","text":"<pre><code>connect()\n</code></pre> <p>Connect to a <code>ToolServer</code>'s <code>ApprovalChannel</code>.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.client.ApprovalClient.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect from the <code>ToolServer</code>'s <code>ApprovalChannel</code>.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.client.ApprovalRequest","title":"ipybox.tool_exec.approval.client.ApprovalRequest","text":"<pre><code>ApprovalRequest(\n    server_name: str,\n    tool_name: str,\n    tool_args: dict[str, Any],\n    respond: Callable[[bool], Awaitable[None]],\n)\n</code></pre> <p>An MCP tool call approval request.</p> <p><code>ApprovalRequest</code> instances are passed to the approval callback registered with <code>ApprovalClient</code>. The callback must call <code>accept</code> or <code>reject</code> for making an approval decision.</p> Example <pre><code>async def on_approval_request(request: ApprovalRequest):\n    print(f\"Approval request: {request}\")\n    if request.tool_name == \"dangerous_tool\":\n        await request.reject()\n    else:\n        await request.accept()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>server_name</code> <code>str</code> <p>Name of the MCP server providing the tool.</p> required <code>tool_name</code> <code>str</code> <p>Name of the tool to execute.</p> required <code>tool_args</code> <code>dict[str, Any]</code> <p>Arguments to pass to the tool.</p> required <code>respond</code> <code>Callable[[bool], Awaitable[None]]</code> <p>Function to make an approval decision.</p> required"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.client.ApprovalRequest.accept","title":"accept  <code>async</code>","text":"<pre><code>accept()\n</code></pre> <p>Accept the approval request.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.client.ApprovalRequest.reject","title":"reject  <code>async</code>","text":"<pre><code>reject()\n</code></pre> <p>Reject the approval request.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.server.ApprovalChannel","title":"ipybox.tool_exec.approval.server.ApprovalChannel","text":"<pre><code>ApprovalChannel(\n    approval_required: bool = False,\n    approval_timeout: float | None = None,\n)\n</code></pre> <p>Server-side channel for tool call approval over WebSocket.</p> <p><code>ApprovalChannel</code> accepts WebSocket connections from an <code>ApprovalClient</code>, sends approval requests via JSON-RPC, and processes approval responses.</p> <p>When <code>approval_required</code> is <code>False</code>, all approval requests are automatically granted. When <code>True</code>, requests are sent to the connected <code>ApprovalClient</code> and the channel waits for a response within the configured timeout.</p> <p>Parameters:</p> Name Type Description Default <code>approval_required</code> <code>bool</code> <p>Whether approval is required for tool execution.</p> <code>False</code> <code>approval_timeout</code> <code>float | None</code> <p>Timeout in seconds for approval requests. If <code>None</code>, no timeout is applied.</p> <code>None</code>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.server.ApprovalChannel.open","title":"open  <code>property</code>","text":"<pre><code>open: bool\n</code></pre> <p>Whether an <code>ApprovalClient</code> is currently connected.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.server.ApprovalChannel.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(websocket: WebSocket)\n</code></pre> <p>Accept a WebSocket connection and process approval responses.</p> <p>This method runs until the WebSocket disconnects.</p> <p>Parameters:</p> Name Type Description Default <code>websocket</code> <code>WebSocket</code> <p>The WebSocket connection to accept.</p> required"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.server.ApprovalChannel.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnect the WebSocket and error all pending approval requests.</p>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.server.ApprovalChannel.join","title":"join  <code>async</code>","text":"<pre><code>join(timeout: float = 5)\n</code></pre> <p>Wait for the this approval channel to close.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Timeout in seconds to wait.</p> <code>5</code>"},{"location":"api/tool_executor/#ipybox.tool_exec.approval.server.ApprovalChannel.request","title":"request  <code>async</code>","text":"<pre><code>request(\n    server_name: str,\n    tool_name: str,\n    tool_args: dict[str, Any],\n) -&gt; bool\n</code></pre> <p>Request approval for a tool call.</p> <p>If <code>approval_required</code> is <code>False</code>, returns <code>True</code> immediately. Otherwise, sends an approval request to the connected <code>ApprovalClient</code> and waits for a response.</p> <p>Parameters:</p> Name Type Description Default <code>server_name</code> <code>str</code> <p>Name of the MCP server providing the tool.</p> required <code>tool_name</code> <code>str</code> <p>Name of the tool to execute.</p> required <code>tool_args</code> <code>dict[str, Any]</code> <p>Arguments to pass to the tool.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if accepted, <code>False</code> if rejected.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no <code>ApprovalClient</code> is connected.</p> <code>TimeoutError</code> <p>If the approval request times out.</p>"}]}